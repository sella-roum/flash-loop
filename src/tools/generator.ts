/**
 * src/tools/generator.ts
 * AIが生成したコードを保存・管理するためのツール
 */
import * as fs from 'node:fs/promises';
import * as path from 'node:path';

export interface IGenerator {
  init(goal: string): Promise<void>;
  /**
   * コード行を追加 (thoughtを含めることでtest.step化)
   */
  appendCode(code: string, thought?: string): Promise<void>;
  finish(): Promise<void>;
  getOutput(): string;
}

export class FileGenerator implements IGenerator {
  private filePath: string;

  constructor() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    this.filePath = path.join(process.cwd(), `generated_test_${timestamp}.spec.ts`);
  }

  async init(goal: string): Promise<void> {
    const header = `import { test, expect } from '@playwright/test';

/**
 * Goal: ${goal}
 * Generated by Flash-Loop
 */
test('FlashLoop Auto-Generated Test', async ({ page }) => {
  test.setTimeout(120000);

`;
    try {
      await fs.writeFile(this.filePath, header, 'utf-8');
    } catch (error) {
      throw new Error(`Failed to create test file: ${error}`);
    }
  }

  async appendCode(code: string, thought?: string): Promise<void> {
    // thoughtがある場合は test.step でラップする
    let block = '';
    if (thought) {
      // エスケープ処理: バックスラッシュを先にエスケープし、その後にシングルクォート等を処理
      const safeThought = thought.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, ' ');

      // インデント調整
      const indentedCode = code
        .split('\n')
        .map((line) => `    ${line}`)
        .join('\n');

      block = `
  await test.step('${safeThought}', async () => {
${indentedCode}
  });`;
    } else {
      // フラットな追記
      block = code
        .split('\n')
        .map((line) => `  ${line}`)
        .join('\n');
    }

    await fs.appendFile(this.filePath, `${block}\n`, 'utf-8');
  }

  async finish(): Promise<void> {
    await fs.appendFile(this.filePath, '});\n', 'utf-8');
  }

  getOutput(): string {
    return this.filePath;
  }
}

export class MemoryGenerator implements IGenerator {
  private codeLines: string[] = [];

  async init(goal: string): Promise<void> {
    this.codeLines.push(`// Start: ${goal}`);
  }

  async appendCode(code: string, thought?: string): Promise<void> {
    if (thought) {
      this.codeLines.push(`// Step: ${thought}`);
    }
    this.codeLines.push(code);
  }

  async finish(): Promise<void> {
    this.codeLines.push('// End');
  }

  getOutput(): string {
    return this.codeLines.join('\n');
  }
}
